use std::{str::FromStr, rc::Rc};
use crate::ast::*;

grammar;

pub Program: Program<Expr> = {
    Declaration* => Program::new(<>)
};

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

Block: Block<Expr> = {
    "{" <s:BlockItem*> "}" => Block::new(s)
}

BlockItem: BlockItem<Expr> = {
    Statement => BlockItem::Statement(<>),
    Declaration => BlockItem::Declaration(<>)
}

Statement: Statement<Expr> = {
    OpenStatement => <>,
    ClosedStatement => <>,
};

OpenStatement: Statement<Expr> = {
    "if" "(" <c:Expr> ")" <t:Statement> => Statement::If(c, Box::new((t, None))),
    "if" "(" <c:Expr> ")" <t:ClosedStatement> "else" <e:OpenStatement> => Statement::If(c, Box::new((t, Some(e)))),
    "while" "(" <cond:Expr> ")" <s:OpenStatement> => Statement::While(cond, Box::new(s), 0),
    "do" <s:OpenStatement> "while" "(" <cond:Expr> ")" ";" => Statement::DoWhile(cond, Box::new(s), 0),

    "for" "(" <init:ForInit> <cond:Expr?> ";" <post:Expr?> ")" <stmt:OpenStatement> => Statement::For { init, cond, post, body: Box::new(stmt), label: 0 },
}

ClosedStatement: Statement<Expr> = {
    NormalStatement => <>,
    "if" "(" <c:Expr> ")" <t:ClosedStatement> "else" <e:ClosedStatement> => Statement::If(c, Box::new((t, Some(e)))),
    "while" "(" <cond:Expr> ")" <s:ClosedStatement> => Statement::While(cond, Box::new(s), 0),
    "do" <s:ClosedStatement> "while" "(" <cond:Expr> ")" ";" => Statement::DoWhile(cond, Box::new(s), 0),

    "for" "(" <init:ForInit> <cond:Expr?> ";" <post:Expr?> ")" <stmt:ClosedStatement> => Statement::For { init, cond, post, body: Box::new(stmt), label: 0 },
}

NormalStatement: Statement<Expr> = {
    "return" <e:Expr?> ";" => Statement::Return(e),
    <e:Expr> ";" => Statement::Expr(e),
    Block => Statement::Block(<>),
    "break" ";" => Statement::Break(0),
    "continue" ";" => Statement::Continue(0),
    "switch" "(" <e:Expr> ")" <b:Block> => Statement::Switch(e, b, 0),
    "case" <Expr> ":" => Statement::Case(<>, 0, 0),
    "default" ":" => Statement::Default(0, 0),
}

ForInit: ForInit<Expr> = {
    Declaration => {
        match <> {
            Declaration::Var(v) => ForInit::Decl(v),
            Declaration::Fn(_) => panic!("Cannot have a function declaration inside a for loop"),
            Declaration::Struct(_) => panic!("Cannot have a struct declaration inside a for loop"),
            Declaration::Union(_) => panic!("Cannot have a struct declaration inside a for loop"),
            Declaration::Enum(_) => panic!("Cannot have an enum declaration inside a for loop"),
        }
    },
    <e:Expr> ";" => ForInit::Expr(e),
    ";" => ForInit::None,
}

Specifier: Specifier = {
    "extern"         => Specifier::Extern,
    "static"         => Specifier::Static,
    "int"            => Specifier::Int,
    "unsigned"       => Specifier::Unsigned,
    "char"           => Specifier::Char,
    "void"           => Specifier::Void,
    "struct" <Ident> => Specifier::Struct(<>),
    "union"  <Ident> => Specifier::Union(<>),
    "enum"   <Ident> => Specifier::Enum(<>),
};

Type: Type = {
    <tas:TypeAndStorageClass> => {
        if tas.1.is_some() {
            panic!("Didn't expect a storage class here!");
        }

        tas.0
    }
}

TypeAndStorageClass: (Type, Option<StorageClass>) = {
    <spec_list:SpecifierList> => {
        let mut types = Vec::new();
        let mut storage_class = None;
        let mut spec_list = spec_list.into_iter();
        while let Some(spec) = spec_list.next() {
            match spec {
                Specifier::Extern => {
                    if storage_class.is_some() { panic!("Cannot have more than one storage class!!!!"); }
                    storage_class = Some(StorageClass::Extern);
                },
                Specifier::Static => {
                    if storage_class.is_some() { panic!("Cannot have more than one storage class!!!!"); }
                    storage_class = Some(StorageClass::Static);
                },

                Specifier::Struct(_)   |
                Specifier::Union(_)    |
                Specifier::Enum(_)     |
                Specifier::Void        |
                Specifier::Char        |
                Specifier::Int         |
                Specifier::Signed      |
                Specifier::Unsigned => {
                    types.push(spec);
                },
            }
        }

        let ty = Type::from_specifiers(types);

        return (ty, storage_class)
    }
};

SimpleDeclarator: Declarator = {
    Ident => Declarator::Ident(<>),
    "(" <Declarator> ")" => <>
};

DirectDeclarator: Declarator = {
    SimpleDeclarator => <>,
    <d: SimpleDeclarator> <p: ParamList> => Declarator::Fn(p, Box::new(d)),
    <d: SimpleDeclarator> <arrs:ArrayDeclLen+> => {
        let mut decl = Declarator::Array(Box::new(d), arrs[0]);
        for n in arrs.into_iter().skip(1) {
            decl = Declarator::Array(Box::new(decl), n);
        }
        decl
    }
};

Declarator: Declarator = {
    "*" <Declarator> => Declarator::Pointer(Box::new(<>)),
    DirectDeclarator => <>,
};

ParamList: Vec<ParamInfo> = {
    "(" "void" ")" => Vec::new(),
    "(" <Comma<Param>> ")" => <>
};

Param: ParamInfo = {
    <t:Type> <d:Declarator> => ParamInfo::new(t, d)
};

Declaration: Declaration<Expr> = {
    <VarDeclWVal> => Declaration::Var(<>),
    <tas:TypeAndStorageClass> <d:Declarator> <block:Block> => {
        let ty = tas.0;
        let storage_class = tas.1;
        let (name, ty, param_names) = d.process(ty);
        
        if let Type::Fn { params, ret_ty } = ty {
            let params = params.into_iter().zip(param_names).collect();

            Declaration::Fn(FunctionDecl::new(name, *ret_ty, params, Some(block), storage_class))
        } else {
            panic!("Variable cannot have a block")
        }
    },
    <tas:TypeAndStorageClass> <d:Declarator> ";" => {
        let ty = tas.0;
        let storage_class = tas.1;
        let (name, ty, param_names) = d.process(ty);
        
        if let Type::Fn { params, ret_ty } = ty {
            let params = params.into_iter().zip(param_names).collect();

            Declaration::Fn(FunctionDecl::new(name, *ret_ty, params, None, storage_class))
        } else {
            Declaration::Var(VarDeclaration::new(name, ty, None, storage_class))
        }
    },
    "struct" <name:Ident> <decls:("{" <MemberDecl+> "}")?> ";" => {
        let decls = decls.unwrap_or(Vec::new());

        Declaration::Struct(StructDeclaration::new(name, decls))
    },
    "union" <name:Ident> <decls:("{" <MemberDecl+> "}")?> ";" => {
        let decls = decls.unwrap_or(Vec::new());

        Declaration::Union(UnionDeclaration::new(name, decls))
    },
    "enum" <name:Ident> <items:("{" <Comma<Ident>> "}")?> ";" => {
        let items = items.unwrap_or(Vec::new());

        Declaration::Enum(EnumDeclaration::new(name, items))
    }
};

MemberDecl: MemberDeclaration = {
    <base_ty:Type> <decl:Declarator> ";" => {
        let (name, ty, _) = decl.process(base_ty);

        if ty.is_fn() {
            panic!("Cannot have a function as a member declaration");
        }

        MemberDeclaration::new(name, ty)
    }
};

VarDeclWVal: VarDeclaration<Expr> = {
    <tas:TypeAndStorageClass> <d:Declarator> "=" <e:Initializer> ";" => {
        let ty = tas.0;
        let storage_class = tas.1;
        let (name, ty, param_names) = d.process(ty);
        
        if matches!(ty, Type::Fn { .. }) {
            panic!("Cannot assign to a variable")
        } else {
            VarDeclaration::new(name, ty, Some(e), storage_class)
        }
    }
};

Initializer: Initializer<Expr> = {
    <Expr> => Initializer::Single(<>),
    <CompoundInit> => <>,
};

// TODO! make fields and compound the same, so we actually follow the standard
CompoundInit: Initializer<Expr> = {
    "{" <Comma<Initializer>> "}" => Initializer::Compound(<>),
    "{"  <first:FieldInitItem> <list:("," <FieldInitItem>)*> "}" => {
        let mut list = list; 
        let mut l = vec![first];
        l.append(&mut list);

        Initializer::Fields(l)
    },
}

FieldInitItem: (Ident, Initializer<Expr>) = {
    "." <n:Ident> "=" <init:Initializer> => (n, init)
}

SpecifierList: Vec<Specifier> = {
    Specifier+ => <>
}

Expr: Expr = {
    Expr14 => <>,
};

Expr14: Expr = {
    <l:Expr13> <o:Assign> <r:Expr14> => Expr::new(DefaultExpr::Binary(BinOp::Assign(o),Box::new((l,r)))),
    Expr13 => <>,
};

Expr13: Expr = {
    <cond:Expr13> "?" <t:Expr> ":" <e:Expr12> => Expr::new(DefaultExpr::Ternary(Box::new((cond,t,e)))),
    Expr12,
};

Expr12: Expr = {
    <l:Expr12> "||" <r:Expr11> => Expr::new(DefaultExpr::Binary(BinOp::Or,Box::new((l,r)))),
    Expr11,
};

Expr11: Expr = {
    <l:Expr11> "&&" <r:Expr10> => Expr::new(DefaultExpr::Binary(BinOp::And,Box::new((l,r)))),
    Expr10,
};

Expr10: Expr = {
    <l:Expr10> "|" <r:Expr9> => Expr::new(DefaultExpr::Binary(BinOp::BitwiseOr,Box::new((l,r)))),
    Expr9,
};

Expr9: Expr = {
    <l:Expr9> "^" <r:Expr8> => Expr::new(DefaultExpr::Binary(BinOp::BitwiseXor,Box::new((l,r)))),
    Expr8,
};

Expr8: Expr = {
    <l:Expr8> "&" <r:Expr7> => Expr::new(DefaultExpr::Binary(BinOp::BitwiseAnd,Box::new((l,r)))),
    Expr7,
};

Expr7: Expr = {
    <l:Expr7> <o:BinOpEqs> <r:Expr6> => Expr::new(DefaultExpr::Binary(o,Box::new((l,r)))),
    Expr6,
};

Expr6: Expr = {
    <l:Expr6> <o:BinOpCmps> <r:Expr5> => Expr::new(DefaultExpr::Binary(o,Box::new((l,r)))),
    Expr5,
};

Expr5: Expr = {
    <l:Expr5> <o:BinOpShifts> <r:Expr4> => Expr::new(DefaultExpr::Binary(o,Box::new((l,r)))),
    Expr4,
};

Expr4: Expr = {
    <l:Expr4> <o:BinOpAddSub> <r:Expr3> => Expr::new(DefaultExpr::Binary(o,Box::new((l,r)))),
    Expr3,
};

Expr3: Expr = {
    <l:Expr3> <o:BinOpMulDivMod> <r:Expr2> => Expr::new(DefaultExpr::Binary(o,Box::new((l,r)))),
    Expr2,
};

Expr2: Expr = {
    Expr1,
};

Expr1: Expr = {
    Expr0,
}

Expr0: Expr = {
    Factor,
};

BinOpMulDivMod: BinOp = {
    "*" => BinOp::Mul,
    "/" => BinOp::Div,
    "%" => BinOp::Mod,
};

BinOpAddSub: BinOp = {
    "+" => BinOp::Add,
    "-" => BinOp::Sub,
};

BinOpShifts: BinOp = {
    "<<" => BinOp::LeftShift,
    ">>" => BinOp::RightShift,
};

BinOpCmps: BinOp = {
    "<" => BinOp::LessThan,
    ">" => BinOp::GreaterThan,
    "<=" => BinOp::LessThanEqual,
    ">=" => BinOp::GreaterThanEqual,
};

BinOpEqs: BinOp = {
    "==" => BinOp::Equal,
    "!=" => BinOp::NotEqual
};

Assign: AssignType = {
    "=" => AssignType::Normal,
    "+=" => AssignType::Add,
    "-=" => AssignType::Sub,
    "*=" => AssignType::Mul,
    "/=" => AssignType::Div,
    "%=" => AssignType::Mod,
    "<<=" => AssignType::LeftShift,
    ">>=" => AssignType::RightShift,
    "&=" => AssignType::BitwiseAnd,
    "|=" => AssignType::BitwiseOr,
    "^=" => AssignType::BitwiseXor
};

Factor: Expr = {
    Cast
};

UnaryTerm: Expr = {
    "+" <Cast> => <>,
    <o:UnOp> <t: Cast> => Expr::new(DefaultExpr::Unary(o, Box::new(t))),
    "sizeof" <UnaryTerm> => Expr::new(DefaultExpr::SizeOf(Box::new(<>))),
    "sizeof" "(" <TypeName> ")" => Expr::new(DefaultExpr::SizeOfT(<>)),
    PostfixTerm => <>,
};

TypeName: Type = {
    <t:Type> <d:AbstractDeclarator?> => if let Some(d) = d { d.process(t) } else { t }
};

Cast: Expr = {
    "(" <ty:TypeName> ")" <e: UnaryTerm> => {
        Expr::new(DefaultExpr::Cast(ty, Box::new(e)))
    },
    UnaryTerm,
}

PostfixTerm: Expr = {
    PrimaryTerm => <>,
    <t:PrimaryTerm> <subs:("[" <Expr> "]")+> => {
        let mut expr = Expr::new(DefaultExpr::Subscript(Box::new((t, subs[0].clone()))));
        for sub in subs.into_iter().skip(1) {
            expr = Expr::new(DefaultExpr::Subscript(Box::new((expr, sub))));
        }
        expr
    },
    <t:PrimaryTerm> <dots:("." <Ident>)+> => {
        let mut expr = Expr::new(DefaultExpr::MemberAccess(Box::new(t), dots[0].clone()));
        for dot in dots.into_iter().skip(1) {
            expr = Expr::new(DefaultExpr::MemberAccess(Box::new(expr), dot));
        }
        expr
    },
    <t:PrimaryTerm> <arrows:("->" <Ident>)+> => {
        let mut expr = Expr::new(DefaultExpr::PtrMemberAccess(Box::new(t), arrows[0].clone()));
        for arrow in arrows.into_iter().skip(1) {
            expr = Expr::new(DefaultExpr::PtrMemberAccess(Box::new(expr), arrow));
        }
        expr
    },
    "(" <ty:TypeName> ")" <i: CompoundInit> => {
        Expr::new(DefaultExpr::CompoundLiteral(ty, Box::new(i)))
    },
    <t:PrimaryTerm> "++" => {
        let op = UnOp::Increment { is_post: true };

        Expr::new(DefaultExpr::Unary(op, Box::new(t)))
    },
    <t:PrimaryTerm> "--" => {
        let op = UnOp::Increment { is_post: true };

        Expr::new(DefaultExpr::Unary(op, Box::new(t)))
    },
};

PrimaryTerm: Expr = {
    <Const> => Expr::new(DefaultExpr::Constant(<>)),
    "(" <Expr> ")",
    Ident => Expr::new(DefaultExpr::Var(<>)),
    <n:Ident> "(" <p:Comma<Expr>> ")" => Expr::new(DefaultExpr::FunctionCall(n, p)),
    <strings:String+> => Expr::new(DefaultExpr::String(strings.join(""))),
};

UnOp: UnOp = {
    "-" => UnOp::Negate,
    "~" => UnOp::Complement,
    "!" => UnOp::Not,
    "*" => UnOp::Dereference,
    "&" => UnOp::AddressOf,
    "++" => UnOp::Increment { is_post: false },
    "--" => UnOp::Increment { is_post: false },
};

AbstractDeclarator: AbstractDeclarator = {
    "*" <AbstractDeclarator?> => {
        let decl = if let Some(d) = <> { d } else { AbstractDeclarator::Base };
        AbstractDeclarator::Pointer(Box::new(decl))
    },
    DirectAbstractDeclarator => <>,
};

DirectAbstractDeclarator: AbstractDeclarator = {
    "(" <AbstractDeclarator> ")" => <>,
    "(" <d:AbstractDeclarator> ")" "[" <n:ArrayDeclLen> "]" => AbstractDeclarator::Array(Box::new(d), n)
};

ArrayDeclLen: u16 = {
    "[" <Const> "]" => {
        match <> {
            Const::Char(n) |
            Const::Int(n) => n as u16,
            Const::UChar(n) |
            Const::UInt(n) => n,
            
            Const::EnumItem{..} => unreachable!(),
        }
    }
};

Const: Const = {
    Int => Const::Int(<>),
    UInt => Const::UInt(<>),
    Char => Const::Int(<>),
};

Int: i16 = {
    r"[0-9]+" => i16::from_str(<>).unwrap()
};

UInt: u16 = {
    r"[0-9]+[uU]" => {
        let l = <>.len();
        let n = &<>[..l-1];
        u16::from_str(n).unwrap()
    }
};

Ident: Ident = {
    r"[a-zA-Z_][a-zA-Z0-9_]*" => Rc::new(<>.to_string()),
};

Char: i16 = {
    <r"'[ -&(-~]'"> => <>.chars().nth(1).unwrap() as i16,
    "'\\''" => 39,
    "'\\\"'" => 34,
    "'\\?'" => 63,
    "'\\\\'" => 92,
    "'\\a'" => 7,
    "'\\b'" => 8,
    "'\\f'" => 12,
    "'\\n'" => 10,
    "'\\r'" => 13,
    "'\\t'" => 9,
    "'\\v'" => 11,
};

String: String = {
    r#""[ -~]*""# => {
        let sn = <>;
        let s = &sn[1..sn.len()-1];
        let mut chars = s.chars();
        let mut string = String::new();
        while let Some(cur_char) = chars.next() {
            if cur_char == '\\' {
                let next = chars.next().unwrap();
                match next {
                    'a' => string.push('\u{07}'),
                    'b' => string.push('\u{08}'),
                    'f' => string.push('\u{12}'),
                    'n' => string.push('\n'),
                    'r' => string.push('\r'),
                    't' => string.push('\t'),
                    'v' => string.push('\u{11}'),
                    _ => string.push(next),
                }
            } else {
                string.push(cur_char);
            }
        }
        string
    }
};