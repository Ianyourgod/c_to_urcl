use std::{str::FromStr, rc::Rc};
use crate::ast::*;

grammar;

pub Program: Program = {
    Declaration* => Program::new(<>)
};

FunctionDecl: FunctionDecl = {
    <tas:TypeAndStorageClass> <n:Ident> "(" <p:ParamList> ")" <b:Block> => FunctionDecl::new(n,p,Some(b), tas.1),
    <tas:TypeAndStorageClass> <n:Ident> "(" <p:ParamList> ")" ";" => FunctionDecl::new(n,p,None, tas.1),
};

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

ParamList: Vec<(Type, String)> = {
    "void" => Vec::new(),
    Comma<(Type Ident)> => <>,
}

Block: Block = {
    "{" <s:BlockItem*> "}" => Block::new(s)
}

Declaration: Declaration = {
    VarDeclaration => Declaration::Var(<>),
    FunctionDecl => Declaration::Fn(<>),
}

BlockItem: BlockItem = {
    Statement => BlockItem::Statement(<>),
    Declaration => BlockItem::Declaration(<>)
}

Statement: Statement = {
    OpenStatement => <>,
    ClosedStatement => <>,
};

OpenStatement: Statement = {
    "if" "(" <c:Expr> ")" <t:Statement> => Statement::If(c, Box::new((t, None))),
    "if" "(" <c:Expr> ")" <t:ClosedStatement> "else" <e:OpenStatement> => Statement::If(c, Box::new((t, Some(e)))),
    "while" "(" <cond:Expr> ")" <s:OpenStatement> => Statement::While(cond, Box::new(s), 0),
    "do" <s:OpenStatement> "while" "(" <cond:Expr> ")" ";" => Statement::DoWhile(cond, Box::new(s), 0),

    "for" "(" <init:ForInit> <cond:Expr?> ";" <post:Expr?> ")" <stmt:OpenStatement> => Statement::For { init, cond, post, body: Box::new(stmt), label: 0 },
}

ClosedStatement: Statement = {
    NormalStatement => <>,
    "if" "(" <c:Expr> ")" <t:ClosedStatement> "else" <e:ClosedStatement> => Statement::If(c, Box::new((t, Some(e)))),
    "while" "(" <cond:Expr> ")" <s:ClosedStatement> => Statement::While(cond, Box::new(s), 0),
    "do" <s:ClosedStatement> "while" "(" <cond:Expr> ")" ";" => Statement::DoWhile(cond, Box::new(s), 0),

    "for" "(" <init:ForInit> <cond:Expr?> ";" <post:Expr?> ")" <stmt:ClosedStatement> => Statement::For { init, cond, post, body: Box::new(stmt), label: 0 },
}

NormalStatement: Statement = {
    "return" <e:Expr> ";" => Statement::Return(e),
    <e:Expr> ";" => Statement::Expr(e),
    Block => Statement::Block(<>),
    "break" ";" => Statement::Break(0),
    "continue" ";" => Statement::Continue(0),
}

ForInit: ForInit = {
    VarDeclaration => ForInit::Decl(<>),
    <e:Expr> ";" => ForInit::Expr(e),
    ";" => ForInit::None,
}

VarDeclaration: VarDeclaration = {
    <tas:TypeAndStorageClass> <n:Ident> <e:("=" <Expr>)?> ";" => VarDeclaration::new(Rc::new(n), e, tas.1),
}

Specifier: Specifier = {
    "extern" => Specifier::Storage(StorageClass::Extern),
    "static" => Specifier::Storage(StorageClass::Static),
    Type     => Specifier::Type(<>),
};

Type: Type = {
    "int" => Type::Int,
};

TypeAndStorageClass: (Type, Option<StorageClass>) = {
    <spec_list:SpecifierList> => {
        let mut types = Vec::new();
        let mut storage_class = None;
        for spec in spec_list {
            match spec {
                Specifier::Storage(c) => {
                    if storage_class.is_some() { panic!("Cannot have more than one storage class!!!!"); }

                    storage_class = Some(c);
                },
                Specifier::Type(ty) => {
                    types.push(ty);
                }
            }
        }

        if types.len() != 1 {
            panic!("Invalid type specifier");
        }

        let ty = Type::Int;

        return (ty, storage_class)
    }
};

SpecifierList: Vec<Specifier> = {
    Specifier+ => <>
}

Expr: Expr = {
    Expr14 => <>,
};

Expr14: Expr = {
    <l:Expr13> <o:Assign> <r:Expr14> => Expr::Binary(BinOp::Assign(o),Box::new((l,r))),
    Expr13 => <>,
};

Expr13: Expr = {
    <cond:Expr13> "?" <t:Expr> ":" <e:Expr12> => Expr::Ternary(Box::new((cond,t,e))),
    Expr12,
};

Expr12: Expr = {
    <l:Expr12> "||" <r:Expr11> => Expr::Binary(BinOp::Or,Box::new((l,r))),
    Expr11,
};

Expr11: Expr = {
    <l:Expr11> "&&" <r:Expr10> => Expr::Binary(BinOp::And,Box::new((l,r))),
    Expr10,
};

Expr10: Expr = {
    <l:Expr10> "|" <r:Expr9> => Expr::Binary(BinOp::BitwiseOr,Box::new((l,r))),
    Expr9,
};

Expr9: Expr = {
    <l:Expr9> "^" <r:Expr8> => Expr::Binary(BinOp::BitwiseXor,Box::new((l,r))),
    Expr8,
};

Expr8: Expr = {
    <l:Expr8> "&" <r:Expr7> => Expr::Binary(BinOp::BitwiseAnd,Box::new((l,r))),
    Expr7,
};

Expr7: Expr = {
    <l:Expr7> <o:BinOpEqs> <r:Expr6> => Expr::Binary(o,Box::new((l,r))),
    Expr6,
};

Expr6: Expr = {
    <l:Expr6> <o:BinOpCmps> <r:Expr5> => Expr::Binary(o,Box::new((l,r))),
    Expr5,
};

Expr5: Expr = {
    <l:Expr5> <o:BinOpShifts> <r:Expr4> => Expr::Binary(o,Box::new((l,r))),
    Expr4,
};

Expr4: Expr = {
    <l:Expr4> <o:BinOpAddSub> <r:Expr3> => Expr::Binary(o,Box::new((l,r))),
    Expr3,
};

Expr3: Expr = {
    <l:Expr3> <o:BinOpMulDivMod> <r:Expr2> => Expr::Binary(o,Box::new((l,r))),
    Expr2,
};

Expr2: Expr = {
    Expr1,
};

Expr1: Expr = {
    Expr0,
}

Expr0: Expr = {
    Term,
};

BinOpMulDivMod: BinOp = {
    "*" => BinOp::Mul,
    "/" => BinOp::Div,
    "%" => BinOp::Mod,
};

BinOpAddSub: BinOp = {
    "+" => BinOp::Add,
    "-" => BinOp::Sub,
};

BinOpShifts: BinOp = {
    "<<" => BinOp::LeftShift,
    ">>" => BinOp::RightShift,
};

BinOpCmps: BinOp = {
    "<" => BinOp::LessThan,
    ">" => BinOp::GreaterThan,
    "<=" => BinOp::LessThanEqual,
    ">=" => BinOp::GreaterThanEqual,
};

BinOpEqs: BinOp = {
    "==" => BinOp::Equal,
    "!=" => BinOp::NotEqual
};

Assign: AssignType = {
    "=" => AssignType::Normal,
    "+=" => AssignType::Add,
    "-=" => AssignType::Sub,
    "*=" => AssignType::Mul,
    "/=" => AssignType::Div,
    "%=" => AssignType::Mod,
    "<<=" => AssignType::LeftShift,
    ">>=" => AssignType::RightShift,
    "&=" => AssignType::BitwiseAnd,
    "|=" => AssignType::BitwiseOr,
    "^=" => AssignType::BitwiseXor
}

Term: Expr = {
    "+"? <n:Num> => Expr::Number(n),
    <o:UnOp> <t: Term> => Expr::Unary(o, Box::new(t)),
    "(" <Expr> ")",
    Ident => Expr::Var(Rc::new(<>)),
    <n:Ident> "(" <p:Comma<Expr>> ")" => Expr::FunctionCall(n.into(), p),
};

UnOp: UnOp = {
    "-" => UnOp::Negate,
    "~" => UnOp::Complement,
    "!" => UnOp::Not
};

Num: i32 = {
    r"[0-9]+" => i32::from_str(<>).unwrap()
};

Ident: String = {
    r"[a-zA-Z_][a-zA-Z0-9_]*" => <>.to_string(),
}